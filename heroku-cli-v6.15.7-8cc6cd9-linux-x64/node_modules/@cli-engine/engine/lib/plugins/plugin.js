"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_ux_1 = require("cli-ux");
const path = require("path");
const rwlockfile_1 = require("rwlockfile");
const deps_1 = require("../deps");
const topic_1 = require("../topic");
class Plugin {
    constructor(opts) {
        this.config = opts.config;
        this.root = opts.root;
        this.pjson = opts.pjson;
        if (!this.pjson['cli-engine'])
            this.pjson['cli-engine'] = {};
        this.name = this.name || this.pjson.name;
        this.version = this.version || this.pjson.version;
        let cacheKey = [this.config.version, this.version].join(path.sep);
        let cacheFile = path.join(this.config.cacheDir, 'plugins', [opts.type, this.name + '.json'].join(path.sep));
        this.cache = new deps_1.default.PluginManifest({ file: cacheFile, invalidate: cacheKey, name: this.name });
        this.debug = require('debug')(`cli:plugins:${[opts.type, this.name, this.version].join(':')}`);
        this.lock = new rwlockfile_1.default(cacheFile, { ifLocked: () => cli_ux_1.default.action.start(`Plugin ${this.name} is updating`) });
        this.type = opts.type;
    }
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const results = {
                commands: yield this.commands(),
                topics: yield this.topics(),
            };
            if (this.cache.needsSave) {
                let canWrite = yield this.lock.check('write');
                if (canWrite.status === 'open') {
                    this.debug('saving cache');
                    yield this.lock.add('write', { reason: 'cache' });
                    yield this.cache.save();
                    yield this.lock.remove('write');
                }
                else {
                    this.debug(`cannot save cache: ${canWrite.status}`);
                }
            }
            return results;
        });
    }
    reset(reload = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.cache.reset();
            if (reload)
                yield this.load();
        });
    }
    findCommand(id, must = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let cmd = yield this.findCommandInModule(id);
            if (!cmd)
                cmd = yield this.findCommandInDir(id);
            if (cmd) {
                cmd = this.addPluginToCommand(cmd);
                return cmd;
            }
            if (must)
                throw new Error(`${id} not found`);
        });
    }
    commands() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cache = yield this.cache.fetch('commands', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.debug('fetching commands');
                const commands = yield deps_1.default
                    .assync([this.commandsFromModule(), this.commandsFromDir()])
                    .flatMap();
                if (!commands.length)
                    throw new Error(`${this.name} has no commands. Is this a CLI plugin?`);
                const r = yield Promise.all(commands);
                return r;
            }));
            return cache.map(c => (Object.assign({}, c, { run: (argv) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield this.lock.add('read', { reason: 'running plugin' });
                    let cmd = yield this.findCommand(c.id, true);
                    let res;
                    if (!c._version || c._version === '0.0.0') {
                        // this.debug('legacy @cli-engine/command version', c._version)
                        res = yield cmd.run(Object.assign({}, this.config, { argv: argv.slice(4) }));
                    }
                    else if (deps_1.default.semver.lt(c._version || '', '10.0.0')) {
                        // this.debug('legacy @cli-engine/command version', c._version)
                        res = yield cmd.run({ argv: argv.slice(1) });
                    }
                    else if (deps_1.default.semver.lt(c._version || '', '11.0.0-beta.0')) {
                        // this.debug(`legacy @cli-engine/command version`, c._version)
                        res = yield cmd.run(Object.assign({}, this.config, { argv: argv.slice(2) }));
                    }
                    else {
                        res = yield cmd.run(argv.slice(3), this.config);
                    }
                    yield this.lock.remove('read');
                    return res;
                }) })));
        });
    }
    topics() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cache = yield this.cache.fetch('topics', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.debug('fetching topics');
                const m = yield this.fetchModule();
                if (!m)
                    return [];
                return m.topics;
            }));
            let pjsonTopics = this.pjson['cli-engine'].topics;
            if (pjsonTopics)
                return cache.concat(topic_1.topicsToArray(pjsonTopics));
            return cache;
        });
    }
    get commandsDir() {
        let d = this.pjson['cli-engine'].commands;
        if (d)
            return path.join(this.root, d);
    }
    commandIDsFromDir() {
        const d = this.commandsDir;
        if (!d)
            return Promise.resolve([]);
        return new Promise((resolve, reject) => {
            let ids = [];
            deps_1.default
                .klaw(d, { depthLimit: 10 })
                .on('data', f => {
                if (!f.stats.isDirectory() &&
                    (f.path.endsWith('.js') || (f.path.endsWith('.ts') && this.type === 'builtin')) &&
                    !f.path.endsWith('.d.ts') &&
                    !f.path.endsWith('.test.js')) {
                    let parsed = path.parse(f.path);
                    let p = path.relative(d, path.join(parsed.dir, parsed.name));
                    if (path.basename(p) === 'index')
                        p = path.dirname(p);
                    ids.push(p.split(path.sep).join(':'));
                }
            })
                .on('error', reject)
                .on('end', () => resolve(ids));
        });
    }
    commandPath(id) {
        if (!this.commandsDir)
            throw new Error('commandsDir not set');
        return require.resolve(path.join(this.commandsDir, id.split(':').join(path.sep)));
    }
    commandsFromModule() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const m = yield this.fetchModule();
            if (!m)
                return [];
            return deps_1.default.assync(m.commands).map(c => this.commandInfoFromICommand(c));
        });
    }
    commandsFromDir() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ids = yield this.commandIDsFromDir();
            return deps_1.default
                .assync(ids)
                .map(id => ({ cmd: this.findCommandInDir(id), id }))
                .map(({ cmd, id }) => this.commandInfoFromICommand(cmd, id));
        });
    }
    commandInfoFromICommand(icommand, id = icommand.id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                id,
                _version: icommand._version,
                description: icommand.description,
                usage: icommand.usage,
                plugin: { name: this.name, version: this.version },
                hidden: icommand.hidden,
                aliases: icommand.aliases || [],
                help: yield icommand.buildHelp(this.config),
                helpLine: yield icommand.buildHelpLine(this.config),
                run: () => tslib_1.__awaiter(this, void 0, void 0, function* () { return cli_ux_1.default.warn(`run ${this.name}`); }),
            };
        });
    }
    findCommandInDir(id) {
        let c = deps_1.default.util.undefault(require(this.commandPath(id)));
        if (!c.id)
            c.id = id;
        return c;
    }
    findCommandInModule(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const m = yield this.fetchModule();
            if (!m)
                return;
            return m.commands.find(c => c.id === id);
        });
    }
    addPluginToCommand(cmd) {
        cmd.plugin = {
            type: this.type,
            root: this.root,
            name: this.name,
            version: this.version,
        };
        return cmd;
    }
    fetchModule() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.pjson.main)
                return;
            if (this._module)
                return this._module;
            return (this._module = (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.debug(`requiring ${this.name}@${this.version}`);
                const m = Object.assign({ commands: [], topics: [] }, require(path.join(this.root, this.pjson.main)));
                if (m.topic)
                    m.topics.push(m.topic);
                m.commands = m.commands.map(deps_1.default.util.undefault);
                const hooks = new deps_1.default.Hooks(this.config);
                yield hooks.run('plugins:parse', { module: m, pjson: this.pjson });
                let legacy = new deps_1.default.PluginLegacy(this.config);
                return legacy.convert(m);
            }))());
        });
    }
}
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'read')
], Plugin.prototype, "load", null);
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'write')
], Plugin.prototype, "reset", null);
tslib_1.__decorate([
    rwlockfile_1.rwlockfile('lock', 'read')
], Plugin.prototype, "findCommand", null);
exports.Plugin = Plugin;
